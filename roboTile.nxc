//right motor is B
//left motor is C
//light sensor is port 1
//left b is port 3
//right b is port 2

int light = 0;
int dark = 0;
int numBlack = 0;
int offSetDark=5;
int offSetLight=10;
int alphaL = 1; //for use with power on left motor
int alphaR = 1; //for use with power on right motor
int power = 20;
int angle90 = 360;
int cAngle = 50;

sub calibrate() {
  TextOut(15,LCD_LINE2,"Light?");
  until(SENSOR_2 == 1); 
  light = SENSOR_1;
  light=light-offSetLight;


  TextOut(15,LCD_LINE2," light = ");
  NumOut(15,LCD_LINE3,light);

  TextOut(15,LCD_LINE5,"Black?");
  until(SENSOR_3 == 1);
  dark = SENSOR_1;
  dark=dark+offSetDark;

  TextOut(15,LCD_LINE5," dark = ");
  NumOut(15,LCD_LINE6,dark);
  Wait(7000);
}

int checkPos(byte outputs){
  long angle = 40;
  int pow = 30;
  int counter = 0;
  bool onBlack;
  if (Sensor(IN_1)<=dark){
     onBlack=true;
  }
     //turn until not on black tile
    while(onBlack){
	counter++;
    	RotateMotor(outputs,pow,angle);
    	if(Sensor(IN_1)>dark){
	    onBlack=false;
    }
  }

  //return to original position
  RotateMotor(outputs,50,-angle*counter);
  return counter;

}


sub correction(){
  int left = checkPos(OUT_B);
  int right = checkPos(OUT_C);

//****** we think this works, but differences in motor = problematic

  int newAng = abs((left-right)/2);
   //increment based on checkPos angle
   //we previously tried using 40, but it was overcorrecting, so need
   //to text with a smaller new angle
  newAng *= 30;

  if (left<right){
     RotateMotor(OUT_C,30,newAng);
  }else{
	RotateMotor(OUT_B,30,newAng);
  }

}


sub startPosition(){
  bool onBlack = false;
  OnFwd(OUT_BC, 30);
  while(!onBlack) {	//continuously check light sensor
    TextOut(15,LCD_LINE6,"Current = ");
    NumOut(15,LCD_LINE7,SENSOR_1);
    if(Sensor(IN_1) <= dark){  //calibrated light sensor
      numBlack++;
      OnFwd(OUT_BC,0);//make it stop
      OnFwd(OUT_BC,20);//move onto tile
      Wait(500);
      Coast(OUT_BC);
      //PlayTone(262,400); //beep
      onBlack = true;
    }
  }
  RotateMotor(OUT_B,power,angle90);
  Wait(1000);
}

sub crossWhiteTile(){
  bool onWhite = false;
  if (Sensor(IN_1)>=light) onWhite = true;
  while(onWhite){
    OnFwd(OUT_BC,40);
    if (Sensor(IN_1)<=dark) onWhite = false;
  }
  Coast(OUT_BC);
  Wait(200);
  correction();
}


sub crossBlackTiles(){
  PlayTone(262,400);
  numBlack++;
  bool onBlack = false;
  if(Sensor(IN_1)<=dark) onBlack = true;
  while(onBlack) {
    OnFwd(OUT_BC,40);
    if (Sensor(IN_1)>=light){
      onBlack = false;
    }
  }
  crossWhiteTile();
}

task main(){
   SetSensorLight(IN_1); // set light sensor
   SetSensor(IN_2,SENSOR_TOUCH); //need to set the touch sensors!
   SetSensor(IN_3,SENSOR_TOUCH);
   calibrate();
   startPosition();
   crossWhiteTile();
   while(numBlack<15){
	crossBlackTiles();
   }
}
